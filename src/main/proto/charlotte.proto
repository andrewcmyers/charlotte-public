syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.isaacsheff.charlotte.proto";
option java_outer_classname = "CharlotteProto";
option objc_class_prefix = "CHARLOTTE";

package charlotte;

import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
// To use Empty: import "google/protobuf/empty.proto";


// ANY_WITH_REFERENCE

// While Any provides a URL field that allows the user to specify a
//  location for the .proto type description, it is conventient in
//  Charlotte to also be able to specify a block, and References are
//  not inherently Strings (although I suppose you coudl marshal a
//  Reference into a String).
message AnyWithReference {
  google.protobuf.Any any = 1; // the datum
  Reference typeBlock = 2; // a reference to a block describing the datum
}


// BASIC CRYPTO PRIMITIVES

message Hash {
  oneof hashalgorithm_oneof {
    AnyWithReference any = 1; // Fill in your own Hash type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    bytes sha3 = 2;
  }
}

message PublicKey {
  message EllipticCurveP256 { // I suppose we may someday want to edit how we store P256s?
    bytes byteString = 1;
  }
  oneof keyalgorithm_oneof {    
    AnyWithReference any = 1; // Fill in your own key type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    EllipticCurveP256 ellipticCurveP256 = 2;
  }
}

message CryptoId { // distinct from PublicKeys, because it might be a hash of a public key, I guess
  oneof idtype_oneof {
    AnyWithReference any = 1; // Fill in your own Id type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    PublicKey publicKey = 2;
    Hash hash = 3;
  }
}

message Signature {
  message SignatureAlgorithmSHA256WithECDSA {
    bytes byteString = 1;
  }
  CryptoId cryptoId = 1;
  oneof signaturealgorithm_oneof {
    AnyWithReference any = 2; // Fill in your own Signature type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    SignatureAlgorithmSHA256WithECDSA sha256WithEcdsa = 3;
  }
}


// BLOCKS

message Reference {
  Hash hash = 1; // the block we're referencing
  repeated Hash availabilityAttestations = 2; // ids of avail. attestations (where to find it)
  repeated Reference integrityAttestations = 3; // ids of relevant integrity attestations (and where to find those)
}

message IntegrityAttestation {
  message ChainSlot {
    Reference block = 1;
    Reference root = 2;
    uint64 slot = 3;
    Reference parent = 4;
  }
  message SignedChainSlot { // I really wish I could make Signed a generic
    ChainSlot chainSlot = 1;
    Signature signature = 2;
  }
  message TimestampedReferences {
    google.protobuf.Timestamp timestamp = 1;
    repeated Reference block = 2;
  }
  message SignedTimestampedReferences {
    TimestampedReferences timestampedReferences = 1;
    Signature signature = 2;
  }
  message GitSimBranch {
    google.protobuf.Timestamp timestamp = 1;
    string branchName = 2;
    Reference commit = 3;
  }
  message SignedGitSimBranch {
    GitSimBranch gitSimBranch = 1;
    Signature signature = 2;
  }
  oneof integrityattestationtype_oneof {
    AnyWithReference any = 1; // Fill in your own Integrity policy type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    SignedChainSlot signedChainSlot = 2;
    SignedTimestampedReferences signedTimestampedReferences = 3;
    SignedGitSimBranch signedGitSimBranch = 4;
  }
}

message AvailabilityAttestation {
  message StoreForever {
    repeated Reference block = 1;
  }
  message SignedStoreForever { // I really wish I could make Signed a generic
    StoreForever storeForever = 1;
    Signature signature = 2;
  }
  oneof availabilityattestationtype_oneof {
    AnyWithReference any = 1; // Fill in your own Availability Attestation type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    SignedStoreForever signedStoreForever = 2;
  }
}

message SignedGitSimCommit {
  message GitSimCommit {
    message GitSimParents {
      message GitSimParent {
        Reference parentCommit = 1;
        bytes diff = 2;
      }
      repeated GitSimParent parent = 1;
    }
    string comment = 1;
    Hash hash = 2;
    oneof commit_oneof {
      bytes initialCommit = 3;
      GitSimParents parents = 4;
    }
  }
  GitSimCommit commit = 1;
  Signature signature = 2;
}

message Block {
  oneof blocktype_oneof {
    AnyWithReference any = 1; // You can store anything as a block.
    string protobuf = 2; // If you want to store a type as a block

    // Technically, we can do everything safely with the above. 
    // However, it is super convenient to have a few built-in types.
    string str = 3; // why not?
    AvailabilityAttestation availabilityAttestation = 4;
    IntegrityAttestation integrityAttestation = 5;
    SignedGitSimCommit signedGitSimCommit= 6;
  }
}


// SERVICES


message SendBlocksInput {
  Block block = 1;
}
message SendBlocksResponse {
  string errorMessage = 1;
}

service CharlotteNode {
  // send blocks to this server.
  // used for gossiping / flooding
  rpc SendBlocks(stream SendBlocksInput) returns (stream SendBlocksResponse) {}
}


// WILBUR

message AvailabilityPolicy {
  oneof availabilitypolicytype_oneof {
    AnyWithReference any = 1; // Fill in your own Availability policy type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    AvailabilityAttestation fillInTheBlank = 2;
  }
}
// just wrappers for the rpc input and output
message RequestAvailabilityAttestationInput {
  AvailabilityPolicy policy = 1;
}
message RequestAvailabilityAttestationResponse {
  string errorMessage = 1;
  Reference reference = 2;
}
service Wilbur { // anything running a Wilbur service should also run a CharlotteNode
  rpc RequestAvailabilityAttestation(RequestAvailabilityAttestationInput) returns (RequestAvailabilityAttestationResponse) {}
}

// WILBUR QUERY

message WilburQueryInput {
  oneof wilburquery_oneof {
    Reference reference = 1;
    Block fillInTheBlank = 2;
  }
}

message WilburQueryResponse {
  string errorMessage = 1;
  repeated Block block = 2;
}

service WilburQuery { // anything running a WilburQuery service should also run a Wilbur and CharlotteNode service
  rpc WilburQuery(WilburQueryInput) returns (WilburQueryResponse) {}
}



// FERN

message IntegrityPolicy {
  oneof integritypolicytype_oneof {
    AnyWithReference any = 1; // Fill in your own Integrity policy type

    // Technically, we can do everything safely with the above.
    // However, it is super convenient to have a few built-in types.
    IntegrityAttestation fillInTheBlank = 2;
    // Eventually, I suppose, some kind of consensus request goes in here.
  }
}
// just wrappers for the RPC input and output
message RequestIntegrityAttestationInput {
  IntegrityPolicy policy = 1;
}
message RequestIntegrityAttestationResponse {
  string errorMessage = 1;
  Reference reference = 2;
}
service Fern { // anything running a Fern service should also run a CharlotteNode
  rpc RequestIntegrityAttestation(RequestIntegrityAttestationInput) returns (RequestIntegrityAttestationResponse) {}
}

