syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.isaacsheff.charlotte.proto";
option java_outer_classname = "CharlotteProto";
option objc_class_prefix = "CHARLOTTE";

package charlotte;

// To use Any: import "google/protobuf/any.proto";
// To use Empty: import "google/protobuf/empty.proto";


// BASIC CRYPTO PRIMITIVES

message Hash {
  oneof hashalgorithm_oneof {
    bytes sha3 = 1;
  }
}

message PublicKey {
  message EllipticCurveP256 { // I suppose we may someday want to edit how we store P256s?
    bytes byteString = 1;
  }
  oneof keyalgorithm_oneof {    
    EllipticCurveP256 ellipticCurveP256 = 1;
  }
}

message CryptoId { // distinct from PublicKeys, because it might be a hash of a public key, I guess
  oneof idtype_oneof {
    PublicKey publicKey = 1;
    Hash hash = 2;
  }
}

message Signature {
  message SignatureAlgorithmSHA256WithECDSA {
    bytes byteString = 1;
  }
  CryptoId cryptoId = 1;
  oneof signaturealgorithm_oneof {
    SignatureAlgorithmSHA256WithECDSA sha256WithEcdsa = 2;
  }
}


// BLOCKS

message Reference {
  Hash hash = 1; // the block we're referencing
  repeated Hash availabilityAttestations = 2; // ids of avail. attestations (where to find it)
  repeated Reference integrityAttestations = 3; // ids of relevant integrity attestations (and where to find those)
}

message IntegrityAttestation {
  message ChainSlot {
    Reference block = 1;
    Reference root = 2;
    uint64 slot = 3;
    Reference parent = 4;
  }
  message SignedChainSlot { // I really wish I could make Signed a generic
    ChainSlot chainSlot = 1;
    Signature signature = 2;
  }
  oneof integrityattestationtype_oneof {
    SignedChainSlot signedChainSlot = 1;
  }
}

message AvailabilityAttestation {
  message StoreForever {
    repeated Reference block = 1;
  }
  message SignedStoreForever { // I really wish I could make Signed a generic
    StoreForever storeForever = 1;
    Signature signature = 2;
  }
  oneof availabilityattestationtype_oneof {
    SignedStoreForever signedStoreForever = 1;
  }
}

message Block {
  oneof blocktype_oneof {
    AvailabilityAttestation availabilityAttestation = 1;
    IntegrityAttestation integrityAttestation = 2;
    string str = 3; // why not?
    HetconsMessage hetconsMessage = 4;
    // This is probably the best place for an Any type, but for now, keep it minimum
  }
}


// SERVICES


message SendBlocksInput {
  Block block = 1;
}
message SendBlocksResponse {
  string errorMessage = 1;
}

service CharlotteNode {
  // send blocks to this server.
  // used for gossiping / flooding
  rpc SendBlocks(stream SendBlocksInput) returns (stream SendBlocksResponse) {}
}


// WILBUR

message AvailabilityPolicy {
  oneof availabilitypolicytype_oneof {
    AvailabilityAttestation fillInTheBlank = 1;
  }
}
// just wrappers for the rpc input and output
message RequestAvailabilityAttestationInput {
  AvailabilityPolicy policy = 1;
}
message RequestAvailabilityAttestationResponse {
  string errorMessage = 1;
  Reference reference = 2;
}
service Wilbur { // anything running a Wilbur service should also run a CharlotteNode
  rpc RequestAvailabilityAttestation(RequestAvailabilityAttestationInput) returns (RequestAvailabilityAttestationResponse) {}
}



// FERN

message IntegrityPolicy {
  oneof integritypolicytype_oneof {
    IntegrityAttestation fillInTheBlank = 1;
    // Eventually, I suppose, some kind of consensus request goes in here.
  }
}
// just wrappers for the RPC input and output
message RequestIntegrityAttestationInput {
  IntegrityPolicy policy = 1;
}
message RequestIntegrityAttestationResponse {
  string errorMessage = 1;
  Reference reference = 2;
}
service Fern { // anything running a Fern service should also run a CharlotteNode
  rpc RequestIntegrityAttestation(RequestIntegrityAttestationInput) returns (RequestIntegrityAttestationResponse) {}
}








// ################################################################

// Hetcons

// ################################################################

// Hetcons version 1.
// Because Protobuf does not support mutual depenency, I temporarily put hetcons code here.

// Utils
message HetconsTime {
  int64 val = 1;
}

message HetconsValue {
  oneof proposedContent_oneof {
    charlotte.Block block = 1;
    int64 num = 2;
  }
}

enum HetconsProposalType {
  BlockSlot = 0;
}


//message HetconsParticipatedAccountsInfo {
//  charlotte.Hash chainHash = 1;
//  HetconsSlot slot = 2;
//}

message HetconsSlot {
  oneof slot_type_oneof {
    int64 blockSlotNumber = 1;
    IntegrityAttestation.ChainSlot chainSlot = 2;
  }
}

message HetconsBallot {
    oneof ballot_onefo {
        int64 ballotNumber = 1;
        string ballotSequence = 2;
    }
}

// Proposal for the next slot provided by clients.
message HetconsProposal {
  HetconsTime time = 1;
  HetconsBallot ballot = 2;
  HetconsValue value = 3;
  HetconsProposalType proposalType = 4;
  repeated IntegrityAttestation.ChainSlot slots = 5;
  charlotte.Hash hash_of_ballot_number_and_time = 6;
  int64 timeout = 7;
}

// references of a quorum of 1bs or 2bs.
message HetconsQuorumRefs {
  repeated charlotte.Hash blockHashes = 1;
}

message HetconsObserverQuorum {
  charlotte.CryptoId owner = 1;
  repeated charlotte.CryptoId memebers = 3;
  // TODO: fault type?
}

message HetconsObserver {
  charlotte.CryptoId id = 1;
  repeated HetconsObserverQuorum quorums = 2;
}

// the group of observers that the message to be sent.
message HetconsObserverGroup {
  repeated HetconsObserver observers = 1;
  repeated Reference chains = 2;
}


// Main Messages
enum HetconsMessageType {
  M1a = 0;
  M1b = 1;
  M2b = 2;
  PROPOSAL = 3;
  OBSERVERGROUP = 4;
}

message HetconsMessage {
  HetconsMessageType type = 4;
  oneof hetconsMessageType_oneof {
    HetconsMessage1a m1a = 1;
    HetconsMessage1b m1b = 2;
    HetconsMessage2ab m2b = 3;
    HetconsProposal proposal = 5;
    HetconsObserverGroup observerGroup = 9;
  }
  Reference observerGroupReferecne = 10;
  charlotte.Signature sig = 7;
  charlotte.CryptoId identity = 8;
}

// Leader Propose the new value with a new bollot number
message HetconsMessage1a {
  HetconsProposal proposal = 1;
  oneof observerGroupFormat_oneof {
    HetconsObserverGroup observerGroup = 2;
  }
}

// Acceptors reply to the leader with (Proposal for bollet b, and previous accepted proposal which is a 2a message
message HetconsMessage1b {
  HetconsMessage1a m1a = 1;
  HetconsMessage2ab m2a = 2;
  HetconsValue value = 3;

}

// 2a and 2b messages have the same format. The difference is that the sig in 2a should be the host server itself.
message HetconsMessage2ab {
  HetconsProposal proposal = 1;
  HetconsQuorumRefs quorum_of_1bs = 2;
  HetconsValue value = 3;
}


// Status

enum HetconsConsensusStage {
  Proposed = 0;
  M1ASent = 1;
  M1BSent = 2;
  QuorumOfM1BReceived = 3;
  M2BSent = 4;
  QuorumOfM2BReceived = 5;
  HetconsTimeout = 6;
  InvalidProposal = 7;
  ConsensusDecided = 8;
  ConsensusAccepted = 9;
  ConsensusFailed = 10;
  ConsensusIdile = 11;
  ConsensusRestart = 12;
}

message HetconsStageStatus {
  message ResponseInfo {
    string status_explaination = 1;
  }
  HetconsConsensusStage stage = 1;
  ResponseInfo info = 2;
}
